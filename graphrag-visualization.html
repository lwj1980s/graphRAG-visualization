<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLL/SLL çŸ¥è¯†å›¾è°±å¯è§†åŒ–</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #2d3748;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 0.9em;
            color: #4a5568;
            font-weight: 600;
        }
        
        select, button {
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            color: #2d3748;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            border: none;
        }
        
        #graph {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }
        
        .links line {
            stroke-opacity: 0.8;
            transition: all 0.3s ease;
        }
        
        .links line:hover {
            stroke-opacity: 1;
            stroke-width: 3;
        }
        
        .nodes circle {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nodes circle:hover {
            stroke-width: 3px;
            filter: brightness(1.2);
        }
        
        .node-text {
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
            font-weight: 500;
        }
        
        .link-text {
            font-size: 10px;
            fill: #718096;
            pointer-events: none;
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
        }
        
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 12px;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            line-height: 1.5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .stats {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-radius: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px 25px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #718096;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§¬ CLL/SLL åŒ»å­¦çŸ¥è¯†å›¾è°±</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>æ•°æ®æºé€‰æ‹©</label>
                <select id="chunkSelect">
                    <option value="all">æ‰€æœ‰æ•°æ®å—</option>
                    <option value="chunk1">æ•°æ®å— 1</option>
                    <option value="chunk2">æ•°æ®å— 2</option>
                </select>
            </div>
            <div class="control-group">
                <label>å¸ƒå±€ç®—æ³•</label>
                <select id="layoutSelect">
                    <option value="force">åŠ›å¯¼å‘å¸ƒå±€</option>
                    <option value="radial">å¾„å‘å¸ƒå±€</option>
                    <option value="hierarchical">å±‚æ¬¡å¸ƒå±€</option>
                </select>
            </div>
            <button onclick="resetZoom()">é‡ç½®è§†å›¾</button>
            <button onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
        </div>
        
        <div id="graph"></div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="nodeCount">0</div>
                <div class="stat-label">å®ä½“èŠ‚ç‚¹</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="edgeCount">0</div>
                <div class="stat-label">å…³ç³»è¾¹</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="clusterCount">0</div>
                <div class="stat-label">èšç±»æ•°</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6B6B;"></div>
                <span>ç–¾ç—…</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ECDC4;"></div>
                <span>ç»„ç»‡æœºæ„</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45B7D1;"></div>
                <span>åœ°åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFA07A;"></div>
                <span>è¯ç‰©/æ²»ç–—</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #98D8C8;"></div>
                <span>å…¶ä»–</span>
            </div>
        </div>
        
        <div class="tooltip"></div>
    </div>

    <script>
        // GraphRAGæ•°æ®
        const graphData = {
            chunk1: {
                entities: ["æ…¢æ€§æ·‹å·´ç»†èƒç™½è¡€ç—…", "CLL", "å°æ·‹å·´ç»†èƒæ·‹å·´ç˜¤", "SLL", "ä¸–ç•Œå«ç”Ÿç»„ç»‡", 
                          "WHO", "ç¾å›½", "ä¸­å›½", "ééœå¥‡é‡‘æ·‹å·´ç˜¤", "NHL", "B ç»†èƒæ¶æ€§è‚¿ç˜¤"],
                triples: [
                    ["æ…¢æ€§æ·‹å·´ç»†èƒç™½è¡€ç—…", "ç¼©å†™", "CLL"],
                    ["å°æ·‹å·´ç»†èƒæ·‹å·´ç˜¤", "ç¼©å†™", "SLL"],
                    ["ä¸–ç•Œå«ç”Ÿç»„ç»‡", "ç¼©å†™", "WHO"],
                    ["æ…¢æ€§æ·‹å·´ç»†èƒç™½è¡€ç—…", "å±äº", "B ç»†èƒæ¶æ€§è‚¿ç˜¤"],
                    ["å°æ·‹å·´ç»†èƒæ·‹å·´ç˜¤", "å±äº", "B ç»†èƒæ¶æ€§è‚¿ç˜¤"],
                    ["æ…¢æ€§æ·‹å·´ç»†èƒç™½è¡€ç—…", "ä¸...è¢«WHOåˆ†ç±»ä¸ºåŒç§ç–¾ç—…", "å°æ·‹å·´ç»†èƒæ·‹å·´ç˜¤"],
                    ["ç¾å›½", "CLL/SLLå¹´å‘ç—…ç‡", "XX.XX/XX,XX"],
                    ["CLL/SLL", "åœ¨ç¾å›½å ç™½è¡€ç—…æ–°å‘ç—…ä¾‹æ¯”ä¾‹", "XX/XX"],
                    ["ä¸­å›½", "CLL/SLLå‘ç—…ç‡", "ç›¸å¯¹è¾ƒä½"],
                    ["CLL/SLL", "åœ¨ä¸­å›½å ééœå¥‡é‡‘æ·‹å·´ç˜¤æ¯”ä¾‹", "XX%ï½XX%"],
                    ["ééœå¥‡é‡‘æ·‹å·´ç˜¤", "åœ¨ä¸­å›½å‘ç—…ç‡", "XX.XX/XX,XX"]
                ]
            },
            chunk2: {
                entities: ["ä¸­å›½", "ç™½è¡€ç—…", "CLL/SLL", "ééœå¥‡é‡‘æ·‹å·´ç˜¤", "NHL", "NCCN", 
                          "CACA", "ACS", "NCI", "ä¸–ç•Œå«ç”Ÿç»„ç»‡", "WHO", "Bruton é…ªæ°¨é…¸æ¿€é…¶", "BTK"],
                triples: [
                    ["CLL/SLL", "å±äº", "ç™½è¡€ç—…"],
                    ["CLL/SLL", "å ", "ééœå¥‡é‡‘æ·‹å·´ç˜¤ï¼ˆNHLï¼‰"],
                    ["ééœå¥‡é‡‘æ·‹å·´ç˜¤", "ç®€ç§°", "NHL"],
                    ["ä¸­å›½", "CLL/SLLå‘ç—…ç‡", "ç›¸å¯¹è¾ƒä½"],
                    ["ä¸­å›½", "NHLå‘ç—…ç‡", "XX.XX/XX,XX"],
                    ["ä¸­å›½", "æ–°å‘CLL/SLLæ‚£è€…æ¯”ç‡", "XX.XX/XX,XX"],
                    ["CLL/SLL", "å¸¸è§äº", "è€å¹´äººç¾¤ä½“"],
                    ["CLL/SLL", "ç”·æ€§å‘ç—…ç‡", "æ›´é«˜"],
                    ["ä¸–ç•Œå«ç”Ÿç»„ç»‡", "ç®€ç§°", "WHO"],
                    ["CLL/SLL", "æ²»ç–—é€‰æ‹©å–å†³äº", "ä¸´åºŠå› ç´ "],
                    ["CLL/SLL", "æ²»ç–—é€‰æ‹©å–å†³äº", "ç”Ÿç‰©å­¦æ ‡å¿—ç‰©"],
                    ["CLL/SLL", "æ²»ç–—é€‰æ‹©å–å†³äº", "æ—¢å¾€æ²»ç–—ç±»å‹"],
                    ["Bruton é…ªæ°¨é…¸æ¿€é…¶", "ç®€ç§°", "BTK"],
                    ["BTKæŠ‘åˆ¶å‰‚", "æ˜¯", "CLL/SLLä¸€çº¿æ²»ç–—é¦–é€‰"]
                ]
            }
        };

        // å®ä½“ç±»å‹åˆ†ç±»å‡½æ•°
        function getNodeType(entity) {
            const diseases = ["æ…¢æ€§æ·‹å·´ç»†èƒç™½è¡€ç—…", "CLL", "å°æ·‹å·´ç»†èƒæ·‹å·´ç˜¤", "SLL", 
                            "ééœå¥‡é‡‘æ·‹å·´ç˜¤", "NHL", "ç™½è¡€ç—…", "CLL/SLL", "B ç»†èƒæ¶æ€§è‚¿ç˜¤"];
            const orgs = ["ä¸–ç•Œå«ç”Ÿç»„ç»‡", "WHO", "NCCN", "CACA", "ACS", "NCI"];
            const locations = ["ç¾å›½", "ä¸­å›½"];
            const treatments = ["Bruton é…ªæ°¨é…¸æ¿€é…¶", "BTK", "BTKæŠ‘åˆ¶å‰‚"];
            
            if (diseases.includes(entity)) return "disease";
            if (orgs.includes(entity)) return "organization";
            if (locations.includes(entity)) return "location";
            if (treatments.includes(entity)) return "treatment";
            return "other";
        }

        // é¢œè‰²æ˜ å°„
        const colorMap = {
            disease: "#FF6B6B",
            organization: "#4ECDC4",
            location: "#45B7D1",
            treatment: "#FFA07A",
            other: "#98D8C8"
        };

        // å¤„ç†æ•°æ®å‡½æ•°
        function processData(selectedChunk) {
            const nodes = new Map();
            const links = [];
            
            let dataToProcess = [];
            if (selectedChunk === 'all') {
                dataToProcess = [...graphData.chunk1.triples, ...graphData.chunk2.triples];
            } else if (selectedChunk === 'chunk1') {
                dataToProcess = graphData.chunk1.triples;
            } else {
                dataToProcess = graphData.chunk2.triples;
            }
            
            // åˆ›å»ºèŠ‚ç‚¹å’Œè¾¹
            dataToProcess.forEach(triple => {
                const [source, relation, target] = triple;
                
                if (!nodes.has(source)) {
                    nodes.set(source, {
                        id: source,
                        type: getNodeType(source),
                        connections: 0
                    });
                }
                
                if (!nodes.has(target)) {
                    nodes.set(target, {
                        id: target,
                        type: getNodeType(target),
                        connections: 0
                    });
                }
                
                nodes.get(source).connections++;
                nodes.get(target).connections++;
                
                links.push({
                    source: source,
                    target: target,
                    relation: relation
                });
            });
            
            return {
                nodes: Array.from(nodes.values()),
                links: links
            };
        }

        // åˆ›å»ºå›¾å½¢
        function createGraph(data) {
            // æ¸…é™¤ä¹‹å‰çš„å›¾
            d3.select("#graph").selectAll("*").remove();
            
            const width = 1340;
            const height = 600;
            
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g");
            
            // æ·»åŠ ç¼©æ”¾åŠŸèƒ½
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            // åˆ›å»ºåŠ›å¯¼å‘æ¨¡æ‹Ÿ
            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links)
                    .id(d => d.id)
                    .distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(30));
            
            // åˆ›å»ºç®­å¤´æ ‡è®°
            svg.append("defs").selectAll("marker")
                .data(["end"])
                .enter().append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 25)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");
            
            // æ·»åŠ è¾¹
            const link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("stroke", "#999")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow)");
            
            // æ·»åŠ è¾¹çš„æ ‡ç­¾
            const linkText = g.append("g")
                .attr("class", "link-texts")
                .selectAll("text")
                .data(data.links)
                .enter().append("text")
                .attr("class", "link-text")
                .text(d => d.relation);
            
            // æ·»åŠ èŠ‚ç‚¹
            const node = g.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(data.nodes)
                .enter().append("circle")
                .attr("r", d => Math.min(10 + d.connections * 2, 25))
                .attr("fill", d => colorMap[d.type])
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // æ·»åŠ èŠ‚ç‚¹æ ‡ç­¾
            const nodeText = g.append("g")
                .attr("class", "node-texts")
                .selectAll("text")
                .data(data.nodes)
                .enter().append("text")
                .attr("class", "node-text")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text(d => d.id);
            
            // å·¥å…·æç¤º
            const tooltip = d3.select(".tooltip");
            
            node.on("mouseover", function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(`<strong>${d.id}</strong><br/>
                            ç±»å‹: ${d.type}<br/>
                            è¿æ¥æ•°: ${d.connections}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });
            
            // æ›´æ–°ä½ç½®
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                linkText
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                nodeText
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
            
            // æ‹–æ‹½å‡½æ•°
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            document.getElementById('nodeCount').textContent = data.nodes.length;
            document.getElementById('edgeCount').textContent = data.links.length;
            
            // è®¡ç®—èšç±»æ•°ï¼ˆç®€å•çš„è¿é€šåˆ†é‡è®¡ç®—ï¼‰
            const clusters = new Set();
            data.nodes.forEach(node => {
                if (node.type) clusters.add(node.type);
            });
            document.getElementById('clusterCount').textContent = clusters.size;
            
            // ä¿å­˜zoomå¯¹è±¡ä¾›é‡ç½®ä½¿ç”¨
            window.currentZoom = zoom;
            window.currentSvg = svg;
        }

        // é‡ç½®ç¼©æ”¾
        function resetZoom() {
            if (window.currentSvg && window.currentZoom) {
                window.currentSvg.transition()
                    .duration(750)
                    .call(window.currentZoom.transform, d3.zoomIdentity);
            }
        }

        // å¯¼å‡ºæ•°æ®
        function exportData() {
            const selectedChunk = document.getElementById('chunkSelect').value;
            const data = processData(selectedChunk);
            const exportObj = {
                nodes: data.nodes,
                links: data.links,
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `graphrag_data_${Date.now()}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        // å¸ƒå±€åˆ‡æ¢
        document.getElementById('layoutSelect').addEventListener('change', function(e) {
            const selectedChunk = document.getElementById('chunkSelect').value;
            const data = processData(selectedChunk);
            
            if (e.target.value === 'radial') {
                // å¾„å‘å¸ƒå±€é€»è¾‘
                const centerNode = data.nodes.reduce((max, node) => 
                    node.connections > max.connections ? node : max
                );
                // å®ç°å¾„å‘å¸ƒå±€...
            } else if (e.target.value === 'hierarchical') {
                // å±‚æ¬¡å¸ƒå±€é€»è¾‘
                // å®ç°å±‚æ¬¡å¸ƒå±€...
            }
            
            createGraph(data);
        });

        // æ•°æ®æºåˆ‡æ¢
        document.getElementById('chunkSelect').addEventListener('change', function(e) {
            const data = processData(e.target.value);
            createGraph(data);
        });

        // åˆå§‹åŒ–
        const initialData = processData('all');
        createGraph(initialData);
    </script>
</body>
</html>